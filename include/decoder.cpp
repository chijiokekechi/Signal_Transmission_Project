#include "decoder.hpp"
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <iomanip>
#include <fstream>
#include <cstring>

/*
 * Name: decoder_t
 * Purpose: Constructor for a decoder object. Takes a size and modulation type to generate a Gray
 *          encoding scheme and constellation map, then adjusts the constellation map for decoding.
 *          Also takes a queue of symbols (complex numbers) generated separately by the (hopefully)
 *          same modulation and encoding scheme and manipulates it internally. This queue will consist
 *          of complex numbers most likely read from stdin. This object also has a precision parameter
 *          that is used to later set the precision of the constellation map and is only needed if a
 *          different value from the default is required.
 */
decoder_t::decoder_t(uint16_t size, string modulation, queue<complex<double>> * q, double precision)
{
    encode(size, modulation, gc, constellation);
    set_constellation(precision);
    set_symbols(q);
}

/*
 * Name: ~decoder_t
 * Purpose: Destructor for the decoder object. Deallocates the internal queue of symbols before
 *          complete destruction of the object.
 */
decoder_t::~decoder_t ()
{
    delete symbols;
}

/*
 * Name: set_symbols
 * Purpose: Dynamically allocates the decoder object's internal queue of symbols (queue), then assigns
 *          the parameter queue to it. This allows the decoder object to manipulate the queue
 *          internally while also having the changes reflected externally.
 */
void decoder_t::set_symbols (queue<complex<double>> * q)
{
    symbols = new queue<complex<double>>;
    symbols = q;
}

/*
 * Name: set_constellation
 * Purpose: Rounds the constellation map generated by the constructor to a specific precision (e.g.
 *          1e6 indicates 6 decimal places of precision). This is necessary due to the queue of
 *          symbols being read from stdin or another file and being limited to the precision they were
 *          written out as. A default precision of 1e6 is provided as a parameter because the default
 *          output is typically 6 decimal places. This can be a different value provided via the
 *          constructor.
 */
void decoder_t::set_constellation (double precision)
{
    for (uint16_t i = 0; i < constellation.size(); i++) {
        constellation.front().real(round(constellation.front().real() * precision) / precision);
        constellation.front().imag(round(constellation.front().imag() * precision) / precision);
        constellation.push_back(constellation.front());
        constellation.pop_front();
    }
}

/*
 * Name: next
 * Purpose: Decodes the next character from the queue of symbols (complex numbers). Uses the size of
 *          the Gray code and constellation map to determine how many symbols to use from the queue.
 *          Each symbol is popped from the internal queue as the next character is decoded, which is
 *          reflected in the external queue associated with the internal queue. This allows the user
 *          to be able to simply check the external queue for emptiness when using the decoder. The
 *          fully decoded character is returned as a byte object (see byte.hpp and byte.cpp for more
 *          details).
 */
byte_t decoder_t::next()
{
    if (symbols->empty()) {
        cerr << "Gray Decoder Error: The symbols list is empty..." << endl
             << "                    Exiting..." << endl;
        exit(EXIT_FAILURE);
    }
    
    int16_t index = -1,
            M = constellation.size(),
            num_bits = log2(M);
    byte_t byte = 0;    //this is necessary for some reason
    
    for (uint8_t i = 0; i < 8/num_bits; i++) {
        for (uint16_t j = 0; j < M; j++) {
            if (symbols->front() == constellation.at(j)) {
                index = j;
                break;
            }
        }
        
        if (index == -1) {
            cerr << "Gray Decoder Error: Invalid symbol" << endl
                 << "                    Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        
        for (uint16_t j = 0; j < M; j++) {
            if (index == gc[j]) {
                index = j;
                break;
            }
        }
        
        byte |= (byte_t(index) << (i * num_bits));
        symbols->pop();
    }
    
    if (M == 2) {
        return ~byte;
    }
    else {
        return byte;
    }
}
